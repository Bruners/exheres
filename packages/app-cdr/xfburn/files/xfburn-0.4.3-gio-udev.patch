From 6eac718663b9800f11d04fffec7a12c131cfd817 Mon Sep 17 00:00:00 2001
From: Lasse Brun <bruners@gmail.com>
Date: Sat, 25 Feb 2012 02:26:45 +0100
Subject: [PATCH] Description: port to gio/udev

Origin: other, https://bugzilla.xfce.org/attachment.cgi?id=3528

Bug: https://bugzilla.xfce.org/show_bug.cgi?id=7355
---
 config.h.in                       |   13 +-
 configure.in                      |   40 +---
 xfburn/Makefile.am                |   23 +-
 xfburn/xfburn-audio-composition.c |   70 ++---
 xfburn/xfburn-blank-dialog.c      |    6 +-
 xfburn/xfburn-data-composition.c  |  118 ++++-----
 xfburn/xfburn-device-box.c        |    4 -
 xfburn/xfburn-device-list.c       |   69 +----
 xfburn/xfburn-device.c            |   10 +-
 xfburn/xfburn-directory-browser.c |   61 ++---
 xfburn/xfburn-hal-manager.c       |  555 -------------------------------------
 xfburn/xfburn-hal-manager.h       |   68 -----
 xfburn/xfburn-main.c              |   32 +--
 xfburn/xfburn-udev-manager.c      |  527 +++++++++++++++++++++++++++++++++++
 xfburn/xfburn-udev-manager.h      |   68 +++++
 15 files changed, 747 insertions(+), 917 deletions(-)
 delete mode 100644 xfburn/xfburn-hal-manager.c
 delete mode 100644 xfburn/xfburn-hal-manager.h
 create mode 100644 xfburn/xfburn-udev-manager.c
 create mode 100644 xfburn/xfburn-udev-manager.h

diff --git a/config.h.in b/config.h.in
index cfa273b..5f6d4f5 100644
--- a/config.h.in
+++ b/config.h.in
@@ -15,9 +15,6 @@
 /* Define to 1 if you have the `bind_textdomain_codeset' function. */
 #undef HAVE_BIND_TEXTDOMAIN_CODESET
 
-/* Define if dbus-glib-1 >= 0.34 present */
-#undef HAVE_DBUS
-
 /* Define to 1 if you have the `dcgettext' function. */
 #undef HAVE_DCGETTEXT
 
@@ -30,8 +27,8 @@
 /* Define if gstreamer-0.10 >= 0.10.2 present */
 #undef HAVE_GST
 
-/* Define if hal-storage >= 0.5.7 present */
-#undef HAVE_HAL
+/* Define if gudev-1.0 >= 145 present */
+#undef HAVE_GUDEV
 
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
@@ -39,9 +36,6 @@
 /* Define if your <locale.h> file defines LC_MESSAGES. */
 #undef HAVE_LC_MESSAGES
 
-/* Define if LIBHAL_DRIVE_CDROM_CAPS_DVDPLUSRWDL present */
-#undef HAVE_LIBHAL_DRIVE_CDROM_CAPS_DVDPLUSRWDL
-
 /* Define to 1 if you have the <locale.h> header file. */
 #undef HAVE_LOCALE_H
 
@@ -66,9 +60,6 @@
 /* Define to 1 if you have the <sys/types.h> header file. */
 #undef HAVE_SYS_TYPES_H
 
-/* Define if thunar-vfs-1 >= 0.3.0 present */
-#undef HAVE_THUNAR_VFS
-
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
diff --git a/configure.in b/configure.in
index af1d218..1b571e2 100644
--- a/configure.in
+++ b/configure.in
@@ -40,45 +40,13 @@ XDT_CHECK_PACKAGE([GTHREAD], [gthread-2.0], [2.6.0])
 XDT_CHECK_PACKAGE([GTK], [gtk+-2.0], [2.10.0])
 XDT_CHECK_PACKAGE([LIBXFCEGUI4], [libxfcegui4-1.0], [4.4.0])
 XDT_CHECK_PACKAGE([EXO], [exo-0.3], [0.3.4], [], [XDT_CHECK_PACKAGE([EXO], [exo-1], [0.3.100])])
-XDT_CHECK_OPTIONAL_PACKAGE([THUNAR_VFS], [thunar-vfs-1], [0.3.0], [thunar-vfs],
-	AC_HELP_STRING([--disable-thunar-vfs],
-			[Disable the use of Thunar's VFS layer to show mime type and icons in file browser]))
-AM_CONDITIONAL([HAVE_THUNAR_VFS], [test "x$THUNAR_VFS_FOUND" = "xyes"])
-
-dnl **********************************
-dnl *** Optional support for D-BUS ***
-dnl **********************************
-dnl (taken from thunar-0.8.0)
-XDT_CHECK_OPTIONAL_PACKAGE([DBUS], [dbus-glib-1],
-                           [0.34], [dbus], [D-BUS support])
+XDT_CHECK_PACKAGE([LIBGIO], [gio-2.0], [2.22.0])
+XDT_CHECK_PACKAGE([LIBGIOUNIX], [gio-unix-2.0], [2.16.0])
 
 dnl ********************************
-dnl *** Check for HAL (optional) ***
+dnl *** Check for gudev (optional) ***
 dnl ********************************
-dnl (taken from libexo's configure.in.in rev.26877)
-XDT_CHECK_OPTIONAL_PACKAGE([HAL], [hal-storage], [0.5.7], [hal], [HAL support], [yes])
-if test x"$HAL_FOUND" = x"yes"; then
-  dnl # substituted into exo-hal-0.3.pc
-  HAL_STORAGE_DEPENDENCY="hal-storage"
-
-  dnl # Check if LIBHAL_DRIVE_CDROM_CAPS_DVDPLUSRWDL is declared
-  save_CFLAGS="$CFLAGS"
-  CFLAGS="$CFLAGS $HAL_CFLAGS"
-  AC_MSG_CHECKING([whether LIBHAL_DRIVE_CDROM_CAPS_DVDPLUSRWDL is declared])
-  AC_COMPILE_IFELSE(AC_LANG_SOURCE(
-  [#include <libhal-storage.h>
-    int main (int argc, char **argv) { return LIBHAL_DRIVE_CDROM_CAPS_DVDPLUSRWDL; }
-  ]),
-  [
-    AC_DEFINE([HAVE_LIBHAL_DRIVE_CDROM_CAPS_DVDPLUSRWDL], [1], [Define if LIBHAL_DRIVE_CDROM_CAPS_DVDPLUSRWDL present])
-    AC_MSG_RESULT([yes])
-  ],
-  [
-    AC_MSG_RESULT([no])
-  ])
-  CFLAGS="$save_CFLAGS"
-fi
-AC_SUBST([HAL_STORAGE_DEPENDENCY])
+XDT_CHECK_OPTIONAL_PACKAGE([GUDEV], [gudev-1.0], [145], [gudev], [UDEV glib support], [yes])
 
 dnl **************************************
 dnl *** Optional support for gstreamer ***
diff --git a/xfburn/Makefile.am b/xfburn/Makefile.am
index e606f56..558a3b3 100644
--- a/xfburn/Makefile.am
+++ b/xfburn/Makefile.am
@@ -28,7 +28,7 @@ xfburn_headers = 							\
 	xfburn-composition.h						\
 	xfburn-compositions-notebook.h					\
 	xfburn-create-iso-progress-dialog.h				\
-	xfburn-hal-manager.h						\
+	xfburn-udev-manager.h						\
 	xfburn-device-box.h						\
 	xfburn-device.h							\
 	xfburn-device-list.h						\
@@ -69,7 +69,7 @@ xfburn_SOURCES =							\
 	xfburn-composition.c						\
 	xfburn-compositions-notebook.c					\
 	xfburn-settings.c						\
-	xfburn-hal-manager.c						\
+	xfburn-udev-manager.c						\
 	xfburn-device-box.c						\
 	xfburn-device.c							\
 	xfburn-device-list.c						\
@@ -97,7 +97,11 @@ xfburn_CFLAGS =								\
 	$(LIBISOFS_CFLAGS)						\
 	$(LIBXFCEGUI4_CFLAGS)						\
 	$(EXO_CFLAGS)							\
-	$(THUNAR_VFS_CFLAGS)						\
+	$(GIO_CFLAGS)							\
+	$(GIO_UNIX_CFLAGS)						\
+	$(GLIB_CFLAGS)							\
+	$(GTHREAD_CFLAGS)						\
+	$(GTK_CFLAGS)							\
 	$(GST_CFLAGS)							\
 	$(GST_PBUTILS_CFLAGS)
 
@@ -108,17 +112,20 @@ xfburn_LDADD = 								\
 	$(LIBISOFS_LIBS)						\
 	$(LIBXFCEGUI4_LIBS)						\
 	$(EXO_LIBS)							\
-	$(THUNAR_VFS_LIBS)						\
+	$(GIO_LIBS)							\
+	$(GIO_UNIX_LIBS)						\
+	$(GLIB_LIBS)							\
+	$(GTHREAD_LIBS)							\
+	$(GTK_LIBS)							\
 	$(GST_LIBS)							\
 	$(GST_PBUTILS_LIBS)
 
-if HAVE_HAL
+if HAVE_GUDEV
 xfburn_CFLAGS +=							\
-	$(HAL_CFLAGS)
+	$(GUDEV_CFLAGS)
 
 xfburn_LDADD += 							\
-	$(HAL_LIBS)
-	$(HAL_DBUS_LIBS)
+	$(GUDEV_LIBS)
 
 endif
 
diff --git a/xfburn/xfburn-audio-composition.c b/xfburn/xfburn-audio-composition.c
index 4e9ceae..7476b77 100644
--- a/xfburn/xfburn-audio-composition.c
+++ b/xfburn/xfburn-audio-composition.c
@@ -34,9 +34,7 @@
 #include <libxfce4util/libxfce4util.h>
 #include <libxfcegui4/libxfcegui4.h>
 
-#ifdef HAVE_THUNAR_VFS
-#include <thunar-vfs/thunar-vfs.h>
-#endif
+#include <gio/gio.h>
 
 #include <exo/exo.h>
 
@@ -1712,26 +1710,6 @@ cb_content_drag_data_rcv (GtkWidget * widget, GdkDragContext * dc, guint x, guin
       for (i=0; files[i] != NULL && files[i][0] != '\0'; i++) {
         gchar *full_path;
 
-#ifdef HAVE_THUNAR_VFS
-        ThunarVfsPath *vfs_path;
-        GError *vfs_error = NULL;
-
-        vfs_path = thunar_vfs_path_new (files[i], &vfs_error);
-
-        if (vfs_error) {
-          g_warning ("Failed to create vfs path for '%s': %s", files[i], vfs_error->message);
-          g_error_free (vfs_error);
-          continue;
-        }
-
-        if (thunar_vfs_path_get_scheme (vfs_path) != THUNAR_VFS_PATH_SCHEME_FILE)
-          continue;
-        full_path = thunar_vfs_path_dup_string (vfs_path);
-
-        thunar_vfs_path_unref (vfs_path);
-
-#else /* no thunar-vfs */
-
         if (g_str_has_prefix (files[i], "file://"))
           full_path = g_build_filename (&files[i][7], NULL);
         else if (g_str_has_prefix (files[i], "file:"))
@@ -1741,7 +1719,8 @@ cb_content_drag_data_rcv (GtkWidget * widget, GdkDragContext * dc, guint x, guin
 
         if (full_path[strlen (full_path) - 1] == '\r')
           full_path[strlen (full_path) - 1] = '\0';
-#endif
+
+        DBG ("Adding path '%s'", full_path);
 
         /* remember path to add it later in another thread */
         priv->full_paths_to_add = g_list_append (priv->full_paths_to_add, full_path);
@@ -1786,29 +1765,46 @@ cb_content_drag_data_rcv (GtkWidget * widget, GdkDragContext * dc, guint x, guin
     }
   } 
   else if (sd->target == gdk_atom_intern ("text/uri-list", FALSE)) {
-#ifdef HAVE_THUNAR_VFS
     GList *vfs_paths = NULL;
     GList *vfs_path;
-    GError *error = NULL;
+    GList *lp;
     gchar *full_path;
+    gchar **uris;
+    gsize   n;
     gboolean ret = FALSE;
 
-    vfs_paths = thunar_vfs_path_list_from_string ((gchar *) sd->data, &error);
+    uris = g_uri_list_extract_uris ((gchar *) sd->data);
+
+    for (n = 0; uris != NULL && uris[n] != NULL; ++n)
+      vfs_paths = g_list_append (vfs_paths, g_file_new_for_uri (uris[n]));
+
+    g_strfreev (uris);
 
     if (G_LIKELY (vfs_paths != NULL)) {
       ThreadAddFilesDragParams *params;
       priv->full_paths_to_add = NULL;
       for (vfs_path = vfs_paths; vfs_path != NULL; vfs_path = g_list_next (vfs_path)) {
-        ThunarVfsPath *path = THUNAR_VFS_PATH (vfs_path->data);
-        if (thunar_vfs_path_get_scheme (path) != THUNAR_VFS_PATH_SCHEME_FILE)
+	GFile *path = vfs_path->data;
+	if (path == NULL)
           continue;
-        full_path = thunar_vfs_path_dup_string (path);
+	/* unable to handle non-local files */
+	if (G_UNLIKELY (!g_file_has_uri_scheme (path, "file"))) {
+            g_object_unref (path);
+	    continue;
+        }
+        full_path = g_file_get_path (path);
+        /* if there is no local path, use the URI (which always works) */
+        if (full_path == NULL)
+            full_path = g_file_get_uri (path);
+        /* release the location */
         g_debug ("adding uri path: %s", full_path);
-
         priv->full_paths_to_add = g_list_prepend (priv->full_paths_to_add, full_path);
         ret = TRUE;
       }
-      thunar_vfs_path_list_free (vfs_paths);
+
+      for (lp = vfs_paths; lp != NULL; lp = lp->next)
+        g_object_unref (lp->data);
+      g_list_free (vfs_paths);
 
       priv->full_paths_to_add = g_list_reverse (priv->full_paths_to_add);
       priv->path_where_insert = path_where_insert;
@@ -1831,18 +1827,10 @@ cb_content_drag_data_rcv (GtkWidget * widget, GdkDragContext * dc, guint x, guin
         cb_adding_done (XFBURN_ADDING_PROGRESS (priv->progress), composition);
       }
     } else {
-      if (G_UNLIKELY (error != NULL))
-        g_warning ("text/uri-list drag failed because '%s'", error->message);
-      else
-        g_warning("There were no files in the uri list!");
+      g_warning("There were no files in the uri list!");
       gtk_drag_finish (dc, FALSE, FALSE, t);
       xfburn_default_cursor (priv->content);
     }
-#else
-    g_warning ("Receiving this type of drag and drop requires thunar-vfs support, sorry!");
-    gtk_drag_finish (dc, FALSE, FALSE, t);
-    xfburn_default_cursor (priv->content);
-#endif
   } 
   else {
     g_warning ("Trying to receive an unsupported drag target, this should not happen.");
diff --git a/xfburn/xfburn-blank-dialog.c b/xfburn/xfburn-blank-dialog.c
index 4fe4eca..7f1974d 100644
--- a/xfburn/xfburn-blank-dialog.c
+++ b/xfburn/xfburn-blank-dialog.c
@@ -30,7 +30,7 @@
 #include "xfburn-device-box.h"
 #include "xfburn-device-list.h"
 #include "xfburn-stock.h"
-#include "xfburn-hal-manager.h"
+#include "xfburn-udev-manager.h"
 #include "xfburn-main.h"
 
 #include "xfburn-blank-dialog.h"
@@ -465,10 +465,10 @@ thread_blank (ThreadBlankParams * params)
  
   g_free (params);
 
-#ifdef HAVE_HAL
+#ifdef HAVE_GUDEV
   gdk_threads_enter ();
   DBG ("blanking done!");
-  xfburn_hal_manager_send_volume_changed ();
+  xfburn_udev_manager_send_volume_changed ();
   gdk_threads_leave ();
 #endif
 }
diff --git a/xfburn/xfburn-data-composition.c b/xfburn/xfburn-data-composition.c
index ef73f78..35a8794 100644
--- a/xfburn/xfburn-data-composition.c
+++ b/xfburn/xfburn-data-composition.c
@@ -37,9 +37,7 @@
 #include <libxfce4util/libxfce4util.h>
 #include <libxfcegui4/libxfcegui4.h>
 
-#ifdef HAVE_THUNAR_VFS
-#include <thunar-vfs/thunar-vfs.h>
-#endif
+#include <gio/gio.h>
 
 #include <exo/exo.h>
 
@@ -288,9 +286,7 @@ xfburn_data_composition_init (XfburnDataComposition * composition)
 
   GtkTargetEntry gte_src[] =  { { "XFBURN_TREE_PATHS", GTK_TARGET_SAME_WIDGET, DATA_COMPOSITION_DND_TARGET_INSIDE } };
   GtkTargetEntry gte_dest[] = { { "XFBURN_TREE_PATHS", GTK_TARGET_SAME_WIDGET, DATA_COMPOSITION_DND_TARGET_INSIDE },
-#ifdef HAVE_THUNAR_VFS
                                 { "text/uri-list", 0, DATA_COMPOSITION_DND_TARGET_TEXT_URI_LIST },
-#endif
                                 { "text/plain;charset=utf-8", 0, DATA_COMPOSITION_DND_TARGET_TEXT_PLAIN },
                               };
 
@@ -1188,14 +1184,14 @@ thread_add_file_to_list_with_name (const gchar *name, XfburnDataComposition * dc
     }
     /* new file */
     else if (S_ISREG (s.st_mode) || S_ISCHR(s.st_mode) || S_ISBLK(s.st_mode) || S_ISLNK (s.st_mode)) {
-#ifdef HAVE_THUNAR_VFS
       GdkScreen *screen;
       GtkIconTheme *icon_theme;
-      ThunarVfsMimeDatabase *mime_database = NULL;
-      ThunarVfsMimeInfo *mime_info = NULL;
-      const gchar *mime_icon_name = NULL;
-      GdkPixbuf *mime_icon = NULL;
+      GdkPixbuf *mime_icon_pixbuf = NULL;
       gint x,y;
+      GFile *file = NULL;
+      GFileInfo *info = NULL;
+      GIcon *mime_icon = NULL;
+      GtkIconInfo *icon_info = NULL;
 
       if (s.st_size > MAXIMUM_ISO_FILE_SIZE) {
         gdk_threads_enter ();
@@ -1208,45 +1204,38 @@ thread_add_file_to_list_with_name (const gchar *name, XfburnDataComposition * dc
       gdk_threads_enter ();
       screen = gtk_widget_get_screen (GTK_WIDGET (dc));
       icon_theme = gtk_icon_theme_get_for_screen (screen);
-      
-      mime_database = thunar_vfs_mime_database_get_default ();
-      mime_info = thunar_vfs_mime_database_get_info_for_file (mime_database, path, NULL);
-          
       gtk_icon_size_lookup (GTK_ICON_SIZE_SMALL_TOOLBAR, &x, &y);
-      mime_icon_name = thunar_vfs_mime_info_lookup_icon_name (mime_info, icon_theme);
-      mime_icon = gtk_icon_theme_load_icon (icon_theme, mime_icon_name, x, 0, NULL);
-#endif
-	
+
+      file = g_file_new_for_path(path);
+      info = g_file_query_info (file, G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE, G_FILE_QUERY_INFO_NONE, NULL, NULL);
+      mime_icon = g_content_type_get_icon (g_file_info_get_content_type (info));
+      if (mime_icon != NULL) {
+        icon_info = gtk_icon_theme_lookup_by_gicon (icon_theme, mime_icon, x, GTK_ICON_LOOKUP_USE_BUILTIN);
+        if (icon_info != NULL) {
+          mime_icon_pixbuf = gtk_icon_info_load_icon (icon_info, NULL);
+          gtk_icon_info_free (icon_info);
+        }
+      }
+
       gtk_tree_store_append (GTK_TREE_STORE (model), iter, parent);
 
       humansize = xfburn_humanreadable_filesize (s.st_size);
 
-#ifdef HAVE_THUNAR_VFS
       gtk_tree_store_set (GTK_TREE_STORE (model), iter,
-                          DATA_COMPOSITION_COLUMN_ICON, (G_IS_OBJECT (mime_icon) ? mime_icon : icon_file),
+                          DATA_COMPOSITION_COLUMN_ICON, (G_IS_OBJECT (mime_icon_pixbuf) ? mime_icon_pixbuf : icon_file),
                           DATA_COMPOSITION_COLUMN_CONTENT, name,
                           DATA_COMPOSITION_COLUMN_HUMANSIZE, humansize,
                           DATA_COMPOSITION_COLUMN_SIZE, (guint64) s.st_size, 
                           DATA_COMPOSITION_COLUMN_PATH, path,
                           DATA_COMPOSITION_COLUMN_TYPE, DATA_COMPOSITION_TYPE_FILE, -1);
-#else
-      gtk_tree_store_set (GTK_TREE_STORE (model), iter,
-                          DATA_COMPOSITION_COLUMN_ICON, icon_file,
-                          DATA_COMPOSITION_COLUMN_CONTENT, name,
-                          DATA_COMPOSITION_COLUMN_HUMANSIZE, humansize,
-                          DATA_COMPOSITION_COLUMN_SIZE, (guint64) s.st_size,
-                          DATA_COMPOSITION_COLUMN_PATH, path,
-                          DATA_COMPOSITION_COLUMN_TYPE, DATA_COMPOSITION_TYPE_FILE, -1);
-#endif
 
       xfburn_disc_usage_add_size (XFBURN_DISC_USAGE (priv->disc_usage), s.st_size);
-#ifdef HAVE_THUNAR_VFS
+
       if (G_LIKELY (G_IS_OBJECT (mime_icon)))
         g_object_unref (mime_icon);
-      thunar_vfs_mime_info_unref (mime_info);
-      g_object_unref (mime_database);
+      if (G_LIKELY (G_IS_OBJECT (file)))
+        g_object_unref(file);
       gdk_threads_leave ();
-#endif
     }
     g_free (humansize);
     g_free (parent);
@@ -1673,26 +1662,6 @@ cb_content_drag_data_rcv (GtkWidget * widget, GdkDragContext * dc, guint x, guin
       for (i=0; files[i] != NULL && files[i][0] != '\0'; i++) {
         gchar *full_path;
 
-#ifdef HAVE_THUNAR_VFS
-        ThunarVfsPath *vfs_path;
-        GError *vfs_error = NULL;
-
-        vfs_path = thunar_vfs_path_new (files[i], &vfs_error);
-
-        if (vfs_error) {
-          g_warning ("Failed to create vfs path for '%s': %s", files[i], vfs_error->message);
-          g_error_free (vfs_error);
-          continue;
-        }
-
-        if (thunar_vfs_path_get_scheme (vfs_path) != THUNAR_VFS_PATH_SCHEME_FILE)
-          continue;
-        full_path = thunar_vfs_path_dup_string (vfs_path);
-
-        thunar_vfs_path_unref (vfs_path);
-
-#else /* no thunar-vfs */
-
         if (g_str_has_prefix (files[i], "file://"))
           full_path = g_build_filename (&files[i][7], NULL);
         else if (g_str_has_prefix (files[i], "file:"))
@@ -1702,7 +1671,6 @@ cb_content_drag_data_rcv (GtkWidget * widget, GdkDragContext * dc, guint x, guin
 
         if (full_path[strlen (full_path) - 1] == '\r')
           full_path[strlen (full_path) - 1] = '\0';
-#endif
 
         DBG ("Adding path '%s'", full_path);
 
@@ -1731,26 +1699,44 @@ cb_content_drag_data_rcv (GtkWidget * widget, GdkDragContext * dc, guint x, guin
     gtk_drag_finish (dc, TRUE, FALSE, t);
   } 
   else if (sd->target == gdk_atom_intern ("text/uri-list", FALSE)) {
-#ifdef HAVE_THUNAR_VFS
     GList *vfs_paths = NULL;
     GList *vfs_path;
-    GError *error = NULL;
+    GList *lp;
     gchar *full_path;
+    gchar **uris;
+    gsize   n;
 
-    vfs_paths = thunar_vfs_path_list_from_string ((gchar *) sd->data, &error);
+    uris = g_uri_list_extract_uris ((gchar *) sd->data);
+
+    for (n = 0; uris != NULL && uris[n] != NULL; ++n)
+      vfs_paths = g_list_append (vfs_paths, g_file_new_for_uri (uris[n]));
+
+    g_strfreev (uris);
 
     if (G_LIKELY (vfs_paths != NULL)) {
       ThreadAddFilesDragParams *params;
       priv->full_paths_to_add = NULL;
       for (vfs_path = vfs_paths; vfs_path != NULL; vfs_path = g_list_next (vfs_path)) {
-        ThunarVfsPath *path = THUNAR_VFS_PATH (vfs_path->data);
-        if (thunar_vfs_path_get_scheme (path) != THUNAR_VFS_PATH_SCHEME_FILE)
+	GFile *path = vfs_path->data;
+	if (path == NULL)
           continue;
-        full_path = thunar_vfs_path_dup_string (path);
+	/* unable to handle non-local files */
+	if (G_UNLIKELY (!g_file_has_uri_scheme (path, "file"))) {
+            g_object_unref (path);
+	    continue;
+        }
+        full_path = g_file_get_path (path);
+        /* if there is no local path, use the URI (which always works) */
+        if (full_path == NULL)
+            full_path = g_file_get_uri (path);
+        /* release the location */
         g_debug ("adding uri path: %s", full_path);
         priv->full_paths_to_add = g_list_prepend (priv->full_paths_to_add, full_path);
       }
-      thunar_vfs_path_list_free (vfs_paths);
+
+      for (lp = vfs_paths; lp != NULL; lp = lp->next)
+        g_object_unref (lp->data);
+      g_list_free (vfs_paths);
 
       priv->full_paths_to_add = g_list_reverse (priv->full_paths_to_add);
       /* FIXME: path_where_insert is always NULL here */
@@ -1769,18 +1755,10 @@ cb_content_drag_data_rcv (GtkWidget * widget, GdkDragContext * dc, guint x, guin
 
       gtk_drag_finish (dc, TRUE, FALSE, t);
     } else {
-      if (G_UNLIKELY (error != NULL))
-        g_warning ("text/uri-list drag failed because '%s'", error->message);
-      else
-        g_warning("There were no files in the uri list!");
+      g_warning("There were no files in the uri list!");
       gtk_drag_finish (dc, FALSE, FALSE, t);
       xfburn_default_cursor (priv->content);
     }
-#else
-    g_warning ("Receiving this type of drag and drop requires thunar-vfs support, sorry!");
-    gtk_drag_finish (dc, FALSE, FALSE, t);
-    xfburn_default_cursor (priv->content);
-#endif
   } 
   else {
     g_warning ("Trying to receive an unsupported drag target, this should not happen.");
diff --git a/xfburn/xfburn-device-box.c b/xfburn/xfburn-device-box.c
index a99d0e9..a7ce7e6 100644
--- a/xfburn/xfburn-device-box.c
+++ b/xfburn/xfburn-device-box.c
@@ -25,10 +25,6 @@
 #include <libxfce4util/libxfce4util.h>
 #include <libxfcegui4/libxfcegui4.h>
 
-#ifdef HAVE_THUNAR_VFS
-#include <thunar-vfs/thunar-vfs.h>
-#endif
-
 #include "xfburn-device-list.h"
 #include "xfburn-device-box.h"
 #include "xfburn-settings.h"
diff --git a/xfburn/xfburn-device-list.c b/xfburn/xfburn-device-list.c
index 4a431d7..5def1aa 100644
--- a/xfburn/xfburn-device-list.c
+++ b/xfburn/xfburn-device-list.c
@@ -34,7 +34,7 @@
 #include <libburn.h>
 
 #include "xfburn-global.h"
-#include "xfburn-hal-manager.h"
+#include "xfburn-udev-manager.h"
 #include "xfburn-utils.h"
 
 #include "xfburn-device-list.h"
@@ -50,7 +50,7 @@ struct _XfburnDeviceListPrivate {
   gint num_burners;
   XfburnDevice *curr_device;
 
-#ifdef HAVE_HAL
+#ifdef HAVE_GUDEV
   gulong volume_changed_handlerid;
 #endif
 };
@@ -58,8 +58,8 @@ struct _XfburnDeviceListPrivate {
 void get_libburn_device_list (XfburnDeviceList *devlist);
 static void cb_combo_device_changed (GtkComboBox *combo, XfburnDeviceList *devlist);
 static void cb_refresh_clicked (GtkButton *button, XfburnDeviceList *devlist);
-#ifdef HAVE_HAL
-static void cb_volumes_changed (XfburnHalManager *halman, XfburnDeviceList *devlist);
+#ifdef HAVE_GUDEV
+static void cb_volumes_changed (XfburnUdevManager *udevman, XfburnDeviceList *devlist);
 #endif
 static XfburnDevice * get_selected_device (GtkComboBox *combo_device);
 static void refresh (XfburnDeviceList *devlist);
@@ -219,64 +219,23 @@ xfburn_device_list_class_init (XfburnDeviceListClass *klass)
   //klass->volume_changed = cb_volume_changed
 }
 
-#if 0
 static void
 xfburn_device_list_init (XfburnDeviceList *self)
 {
   XfburnDeviceListPrivate *priv = GET_PRIVATE (self);
 
-#ifdef HAVE_HAL
-  XfburnHalManager *halman = xfburn_hal_manager_get_global ();
+#ifdef HAVE_GUDEV
+  XfburnUdevManager *udevman = xfburn_udev_manager_get_global ();
 #endif
 
   DBG ("Constructing device list");
   xfburn_console_libburn_messages ();
 
-#ifdef HAVE_HAL
-  /* FIXME: hal_manager currently only returns burners, not readers */
-  priv->num_drives = priv->num_burners = xfburn_hal_manager_get_devices (halman, &priv->devices);
-  if (priv->num_burners < 1) {
-    /* if some error occurred while checking hal properties,
-       or hal for some reason did not find a device, then just
-       fall back on libburn */
-    g_message ("HAL said there are %d burners, checking libburn if it can detect any", priv->num_burners);
-
-    get_libburn_device_list (self);
-  }
-
-  priv->volume_changed_handlerid = g_signal_connect (G_OBJECT (xfburn_hal_manager_get_global ()), "volume-changed", G_CALLBACK (cb_volumes_changed), self);
-
-#else
-  get_libburn_device_list (self);
-#endif
-}
-#endif
-
-static void
-xfburn_device_list_init (XfburnDeviceList *self)
-{
-  XfburnDeviceListPrivate *priv = GET_PRIVATE (self);
-
-#ifdef HAVE_HAL
-  XfburnHalManager *halman = xfburn_hal_manager_get_global ();
-#endif
-
-  DBG ("Constructing device list");
-  xfburn_console_libburn_messages ();
-
-#ifdef HAVE_HAL
-  /* FIXME: hal_manager currently only returns burners, not readers */
-  priv->num_drives = priv->num_burners = xfburn_hal_manager_get_devices (halman, &priv->devices);
-  if (priv->num_burners < 1) {
-    /* if some error occurred while checking hal properties,
-       or hal for some reason did not find a device, then just
-       fall back on libburn */
-    g_message ("HAL said there are %d burners, checking libburn if it can detect any", priv->num_burners);
-
-    get_libburn_device_list (self);
-  }
-  priv->volume_changed_handlerid = g_signal_connect (G_OBJECT (xfburn_hal_manager_get_global ()), "volume-changed", G_CALLBACK (cb_volumes_changed), self);
-
+#ifdef HAVE_GUDEV
+  priv->devices = xfburn_udev_manager_get_devices (udevman, &priv->num_drives, &priv->num_burners);
+  if (priv->num_drives > 0 && priv->num_burners < 1)
+    g_warning ("There are %d drives in your system, but none are capable of burning", priv->num_drives);
+  priv->volume_changed_handlerid = g_signal_connect (G_OBJECT (xfburn_udev_manager_get_global ()), "volume-changed", G_CALLBACK (cb_volumes_changed), self);
 #else
   get_libburn_device_list (self);
 #endif
@@ -383,11 +342,11 @@ cb_combo_device_changed (GtkComboBox *combo, XfburnDeviceList *devlist)
   g_signal_emit (G_OBJECT (devlist), signals[VOLUME_CHANGE_END], 0, TRUE, device);
 }
 
-#ifdef HAVE_HAL
+#ifdef HAVE_GUDEV
 static void
-cb_volumes_changed (XfburnHalManager *halman, XfburnDeviceList *devlist)
+cb_volumes_changed (XfburnUdevManager *udevman, XfburnDeviceList *devlist)
 {
-  DBG ("Hal volume changed");
+  DBG ("Udev volume changed");
   refresh (devlist);
 }
 #endif
diff --git a/xfburn/xfburn-device.c b/xfburn/xfburn-device.c
index 73727db..a799013 100644
--- a/xfburn/xfburn-device.c
+++ b/xfburn/xfburn-device.c
@@ -25,7 +25,7 @@
 #include <unistd.h>
 
 #include "xfburn-device.h"
-#include "xfburn-hal-manager.h"
+#include "xfburn-udev-manager.h"
 
 /*- globals -*/
 
@@ -430,8 +430,8 @@ xfburn_device_grab (XfburnDevice * device, struct burn_drive_info **drive_info)
   gchar drive_addr[BURN_DRIVE_ADR_LEN];
   int i;
   const int max_checks = 4;
-#ifdef HAVE_HAL
-  XfburnHalManager *halman = xfburn_hal_manager_get_global ();
+#ifdef HAVE_GUDEV
+  XfburnUdevManager *udevman = xfburn_udev_manager_get_global ();
 #endif
 
   ret = burn_drive_convert_fs_adr (priv->addr, drive_addr);
@@ -448,8 +448,8 @@ xfburn_device_grab (XfburnDevice * device, struct burn_drive_info **drive_info)
     if (ret > 0)
       break;
     else if  (i < max_checks) {
-#ifdef HAVE_HAL 
-      if (!xfburn_hal_manager_check_ask_umount (halman, device))
+#ifdef HAVE_GUDEV
+      if (!xfburn_udev_manager_check_ask_umount (udevman, device))
         usleep(i*100001);
 #else
       usleep(i*100001);
diff --git a/xfburn/xfburn-directory-browser.c b/xfburn/xfburn-directory-browser.c
index f88a3f6..09778cd 100644
--- a/xfburn/xfburn-directory-browser.c
+++ b/xfburn/xfburn-directory-browser.c
@@ -28,9 +28,7 @@
 #include <libxfce4util/libxfce4util.h>
 #include <libxfcegui4/libxfcegui4.h>
 
-#ifdef HAVE_THUNAR_VFS
-#include <thunar-vfs/thunar-vfs.h>
-#endif
+#include <gio/gio.h>
 
 #include <exo/exo.h>
 
@@ -315,44 +313,35 @@ xfburn_directory_browser_load_path (XfburnDirectoryBrowser * browser, const gcha
       }
       else if ((s.st_mode & S_IFREG)) {
         GtkTreeIter iter;
-#ifdef HAVE_THUNAR_VFS
-		ThunarVfsMimeDatabase *mime_database = NULL;
-		ThunarVfsMimeInfo *mime_info = NULL;
-		const gchar *mime_icon_name = NULL;
-		GdkPixbuf *mime_icon = NULL;
-		const gchar *mime_str = NULL;
-#endif
-		
+        GFileInfo *mime_info = NULL;
+        GIcon *mime_icon = NULL;
+        GdkPixbuf *mime_icon_pixbuf = NULL;
+        const gchar *mime_str = NULL;
+        GFile *file = NULL;
+        const gchar *content_type = NULL;
+
         gtk_list_store_append (GTK_LIST_STORE (model), &iter);
-		
-#ifdef HAVE_THUNAR_VFS
-		mime_database = thunar_vfs_mime_database_get_default ();
-		mime_info = thunar_vfs_mime_database_get_info_for_file (mime_database, path_utf8, NULL);
-		
-		mime_icon_name = thunar_vfs_mime_info_lookup_icon_name (mime_info, icon_theme);
-		mime_icon = gtk_icon_theme_load_icon (icon_theme, mime_icon_name, x, 0, NULL);
-		
-		mime_str = thunar_vfs_mime_info_get_comment (mime_info);
-		
-		gtk_list_store_set (GTK_LIST_STORE (model), &iter,
-                            DIRECTORY_BROWSER_COLUMN_ICON, (G_IS_OBJECT (mime_icon) ? mime_icon : icon_file),
+
+        file = g_file_new_for_path(path_utf8);
+        mime_info = g_file_query_info (file, G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE, G_FILE_QUERY_INFO_NONE, NULL, NULL);
+        content_type = g_file_info_get_content_type (mime_info);
+	mime_str = g_content_type_get_description (content_type);
+        mime_icon = g_content_type_get_icon (content_type);
+        if (mime_icon != NULL) {
+            GtkIconInfo *icon_info = gtk_icon_theme_lookup_by_gicon (icon_theme, mime_icon, x, GTK_ICON_LOOKUP_USE_BUILTIN);
+            if (icon_info != NULL) {
+                mime_icon_pixbuf = gtk_icon_info_load_icon (icon_info, NULL);
+                gtk_icon_info_free (icon_info);
+            }
+            g_object_unref (mime_icon);
+        }
+	gtk_list_store_set (GTK_LIST_STORE (model), &iter,
+                            DIRECTORY_BROWSER_COLUMN_ICON, (G_IS_OBJECT (mime_icon_pixbuf) ? mime_icon_pixbuf : icon_file),
                             DIRECTORY_BROWSER_COLUMN_FILE, dir_entry,
                             DIRECTORY_BROWSER_COLUMN_HUMANSIZE, humansize,
                             DIRECTORY_BROWSER_COLUMN_SIZE, (guint64) s.st_size,
                             DIRECTORY_BROWSER_COLUMN_TYPE, mime_str, DIRECTORY_BROWSER_COLUMN_PATH, path_utf8, -1);
-		
-		if (G_LIKELY (G_IS_OBJECT (mime_icon)))
-		  g_object_unref (mime_icon);
-		thunar_vfs_mime_info_unref (mime_info);
-		g_object_unref (mime_database);
-#else
-        gtk_list_store_set (GTK_LIST_STORE (model), &iter,
-                            DIRECTORY_BROWSER_COLUMN_ICON, icon_file,
-                            DIRECTORY_BROWSER_COLUMN_FILE, dir_entry,
-                            DIRECTORY_BROWSER_COLUMN_HUMANSIZE, humansize,
-                            DIRECTORY_BROWSER_COLUMN_SIZE, (guint64) s.st_size,
-                            DIRECTORY_BROWSER_COLUMN_TYPE, _("File"), DIRECTORY_BROWSER_COLUMN_PATH, path_utf8, -1);
-#endif
+        g_object_unref(file);
       }
       g_free (humansize);
       g_free (path_utf8);
diff --git a/xfburn/xfburn-hal-manager.c b/xfburn/xfburn-hal-manager.c
deleted file mode 100644
index 3d64cad..0000000
--- a/xfburn/xfburn-hal-manager.c
+++ /dev/null
@@ -1,555 +0,0 @@
-/*
- *  Copyright (c) 2005-2006 Jean-François Wauthy (pollux@xfce.org)
- *  Copyright (c) 2008      David Mohr (dmohr@mcbf.net)
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifdef	HAVE_CONFIG_H
-#include <config.h>
-#endif /* !HAVE_CONFIG_H */
-
-#ifdef HAVE_HAL
-
-#ifdef HAVE_STRING_H
-#include <string.h>
-#endif
-
-#include <libhal-storage.h>
-
-#include <errno.h>
-
-#include <libxfce4util/libxfce4util.h>
-#ifdef HAVE_THUNAR_VFS
-# include <thunar-vfs/thunar-vfs.h>
-#endif
-#include <libxfcegui4/libxfcegui4.h>
-
-#include "xfburn-global.h"
-#include "xfburn-progress-dialog.h"
-#include "xfburn-device-list.h"
-
-#include "xfburn-hal-manager.h"
-
-static void xfburn_hal_manager_class_init (XfburnHalManagerClass * klass);
-static void xfburn_hal_manager_init (XfburnHalManager * obj);
-static void xfburn_hal_manager_finalize (GObject * object);
-
-static GObject * xfburn_hal_manager_new (void);
-
-static void hal_finalize (LibHalContext  *hal_context);
-static void cb_device_added (LibHalContext *ctx, const char *udi);
-static void cb_device_removed (LibHalContext *ctx, const char *udi);
-static void cb_prop_modified (LibHalContext *ctx, const char *udi, const char *key,
-                              dbus_bool_t is_removed, dbus_bool_t is_added);
-
-#define XFBURN_HAL_MANAGER_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), XFBURN_TYPE_HAL_MANAGER, XfburnHalManagerPrivate))
-
-enum {
-  VOLUME_CHANGED,
-  LAST_SIGNAL,
-}; 
-
-typedef struct {
-  LibHalContext  *hal_context;
-  DBusConnection *dbus_connection;
-  gchar *error;
-
-#ifdef HAVE_THUNAR_VFS
-  ThunarVfsVolumeManager *thunar_volman;
-#endif
-} XfburnHalManagerPrivate;
-
-static XfburnHalManager *instance = NULL;
-
-/*********************/
-/* class declaration */
-/*********************/
-static XfburnProgressDialogClass *parent_class = NULL;
-static guint signals[LAST_SIGNAL];
-
-GType
-xfburn_hal_manager_get_type (void)
-{
-  static GType type = 0;
-
-  if (type == 0) {
-    static const GTypeInfo our_info = {
-      sizeof (XfburnHalManagerClass),
-      NULL,
-      NULL,
-      (GClassInitFunc) xfburn_hal_manager_class_init,
-      NULL,
-      NULL,
-      sizeof (XfburnHalManager),
-      0,
-      (GInstanceInitFunc) xfburn_hal_manager_init,
-      NULL
-    };
-
-    type = g_type_register_static (G_TYPE_OBJECT, "XfburnHalManager", &our_info, 0);
-  }
-
-  return type;
-}
-
-static void
-xfburn_hal_manager_class_init (XfburnHalManagerClass * klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  
-  g_type_class_add_private (klass, sizeof (XfburnHalManagerPrivate));
-  
-  parent_class = g_type_class_peek_parent (klass);
-
-  object_class->finalize = xfburn_hal_manager_finalize;
-
-  signals[VOLUME_CHANGED] = g_signal_new ("volume-changed", XFBURN_TYPE_HAL_MANAGER, G_SIGNAL_ACTION,
-                                          G_STRUCT_OFFSET (XfburnHalManagerClass, volume_changed),
-                                          NULL, NULL, g_cclosure_marshal_VOID__VOID,
-                                          G_TYPE_NONE, 0);
-}
-
-static void
-xfburn_hal_manager_init (XfburnHalManager * obj)
-{
-  XfburnHalManagerPrivate *priv = XFBURN_HAL_MANAGER_GET_PRIVATE (obj);
-  LibHalContext  *hal_context = NULL;
-  DBusError derror;
-  //GError *error = NULL;
-
-  DBusConnection *dbus_connection;
-  priv->error = NULL;
-
-  //if (instance != NULL)
-  //  g_error ("The HAL context was already there when trying to create a hal-manager!");
-  
-  /* dbus & hal init code taken from exo */
-  /* initialize D-Bus error */
-  dbus_error_init (&derror);
-
-  /* try to connect to the system bus */
-  dbus_connection = dbus_bus_get (DBUS_BUS_SYSTEM, &derror);
-  if (G_LIKELY (dbus_connection != NULL)) {
-    /* try to allocate a new HAL context */
-    hal_context = libhal_ctx_new ();
-    if (G_LIKELY (hal_context != NULL)) {
-      /* setup the D-Bus connection for the HAL context */
-      if (libhal_ctx_set_dbus_connection (hal_context, dbus_connection)) {
-
-        /* try to initialize the HAL context */
-        libhal_ctx_init (hal_context, &derror);
-      } else {
-        dbus_set_error_const (&derror, DBUS_ERROR_NO_MEMORY, g_strerror (ENOMEM));
-      }
-    } else {
-      /* record the allocation failure of the context */
-      dbus_set_error_const (&derror, DBUS_ERROR_NO_MEMORY, g_strerror (ENOMEM));
-    }
-  }
-
-  /* check if we failed */
-  if (dbus_error_is_set (&derror)) {
-    /* check if a HAL context was allocated */
-    if (G_UNLIKELY (hal_context != NULL)) {
-      /* drop the allocated HAL context */
-      hal_finalize (hal_context);
-      hal_context = NULL;
-      priv->error = "HAL";
-    } else {
-      priv->error = "DBus";
-    }
-    dbus_error_free (&derror);
-  } else {
-    if (!libhal_ctx_set_device_added (hal_context, cb_device_added))
-      g_warning ("Could not setup HAL callback for device_added");
-
-    if (!libhal_ctx_set_device_removed (hal_context, cb_device_removed))
-      g_warning ("Could not setup HAL callback for device_removed");
-
-    if (!libhal_ctx_set_device_property_modified (hal_context, cb_prop_modified))
-      g_warning ("Could not setup HAL callback for prop_modified");
-  }
-
-  priv->hal_context = hal_context;
-  priv->dbus_connection = dbus_connection;
-
-#ifdef HAVE_THUNAR_VFS
-  /* FIXME: for some weird reason the hal callbacks don't actually work, 
-   *        unless we also fetch an instance of thunar_vfs_volman. Why??
-   *    Not terrible though, because we'll need to use it eventually anyways */
-  priv->thunar_volman = thunar_vfs_volume_manager_get_default ();
-  if (priv->thunar_volman != NULL) {
-    //g_signal_connect (G_OBJECT (priv->thunar_volman), "volumes-added", G_CALLBACK (cb_volumes_changed), box);
-    //g_signal_connect (G_OBJECT (priv->thunar_volman), "volumes-removed", G_CALLBACK (cb_volumes_changed), box);
-  } else {
-    g_warning ("Error trying to access thunar-vfs-volume-manager!");
-  }
-  /*
-  */
-#endif
-}
-
-static void
-xfburn_hal_manager_finalize (GObject * object)
-{
-  XfburnHalManagerPrivate *priv = XFBURN_HAL_MANAGER_GET_PRIVATE (object);
-
-#ifdef HAVE_THUNAR_VFS
-  g_object_unref (priv->thunar_volman);
-#endif
-
-  hal_finalize (priv->hal_context);
-
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-  instance = NULL;
-}
-
-/*           */
-/* internals */
-/*           */
-static void
-hal_finalize (LibHalContext  *hal_context)
-{
-  DBusError derror;
-
-  dbus_error_init (&derror);
-  libhal_ctx_shutdown (hal_context, &derror);
-  if (dbus_error_is_set (&derror)) {
-    DBG ("Error shutting hal down!");
-  }
-  dbus_error_free (&derror);
-  libhal_ctx_free (hal_context);
-}
-
-static void cb_device_added (LibHalContext *ctx, const char *udi)
-{
-  DBG ("HAL: device added");
-  g_signal_emit (instance, signals[VOLUME_CHANGED], 0);
-}
-
-static void cb_device_removed (LibHalContext *ctx, const char *udi)
-{
-  DBG ("HAL: device removed");
-  g_signal_emit (instance, signals[VOLUME_CHANGED], 0);
-}
-
-static void cb_prop_modified (LibHalContext *ctx, const char *udi,
-                              const char *key, dbus_bool_t is_removed, dbus_bool_t is_added)
-{
-  /* Lets ignore this for now,
-   * way too many of these get triggered when a disc is
-   * inserted or removed!
-  DBG ("HAL: property modified");
-  g_signal_emit (instance, signals[VOLUME_CHANGED], 0);
-  */
-}
-
-static GObject *
-xfburn_hal_manager_new (void)
-{
-  if (G_UNLIKELY (instance != NULL))
-    g_error ("Trying to create a second instance of hal manager!");
-  return g_object_new (XFBURN_TYPE_HAL_MANAGER, NULL);
-}
-
-/*        */
-/* public */
-/*        */
-
-gchar *
-xfburn_hal_manager_create_global (void)
-{
-  XfburnHalManagerPrivate *priv;
-
-  instance = XFBURN_HAL_MANAGER (xfburn_hal_manager_new ());
-
-  priv = XFBURN_HAL_MANAGER_GET_PRIVATE (instance);
-
-  if (priv->error) {
-    gchar *error_msg, *ret;
-
-    error_msg = g_strdup (priv->error);
-    xfburn_hal_manager_shutdown ();
-    ret = g_strdup_printf ("Failed to initialize %s!", error_msg);
-    g_free (error_msg);
-    return ret;
-  } else
-    return NULL;
-}
-
-XfburnHalManager *
-xfburn_hal_manager_get_global (void)
-{
-  if (G_UNLIKELY (instance == NULL))
-    g_error ("There is no instance of a hal manager!");
-  return instance;
-}
-
-void
-xfburn_hal_manager_shutdown (void)
-{
-  if (G_UNLIKELY (instance == NULL))
-    g_error ("There is no instance of a hal manager!");
-  g_object_unref (instance);
-  instance = NULL;
-}
-
-void
-xfburn_hal_manager_send_volume_changed (void)
-{
-  //gdk_threads_enter ();
-  g_signal_emit (instance, signals[VOLUME_CHANGED], 0);
-  //gdk_threads_leave ();
-}
-
-int 
-xfburn_hal_manager_get_devices (XfburnHalManager *halman, GList **device_list)
-{
-  XfburnHalManagerPrivate *priv = XFBURN_HAL_MANAGER_GET_PRIVATE (halman);
-  char **all_devices, **devices;
-  int num;
-  DBusError error;
-  int n_devices = 0;
-
-  dbus_error_init (&error);
-
-  all_devices = libhal_get_all_devices (priv->hal_context, &num, &error);
-
-  if (dbus_error_is_set (&error)) {
-    g_warning ("Could not get list of devices from HAL: %s", error.message);
-    return -1;
-  }
-
-  for (devices = all_devices; *devices != NULL; devices++) {
-    dbus_bool_t exists;
-    char **cap_list, **caps;
-    gboolean optical_drive = FALSE;
-
-    exists = libhal_device_property_exists (priv->hal_context, *devices, "info.capabilities", &error);
-    if (dbus_error_is_set (&error)) {
-      g_warning ("Error checking HAL property for %s: %s", *devices, error.message);
-      dbus_error_free (&error);
-      return -1;
-    }
-
-    if (!exists)
-      continue;
-
-    cap_list = libhal_device_get_property_strlist (priv->hal_context, *devices, "info.capabilities", &error);
-    if (dbus_error_is_set (&error)) {
-      g_warning ("Error getting HAL property for %s: %s", *devices, error.message);
-      dbus_error_free (&error);
-      return -1;
-    }
-
-    for (caps = cap_list; *caps != NULL; caps++) {
-      if (strcmp (*caps, "storage.cdrom") == 0) {
-        exists = libhal_device_property_exists (priv->hal_context, *devices, "storage.cdrom.write_speed", &error);
-        if (dbus_error_is_set (&error)) {
-          g_warning ("Error checking HAL property for %s: %s", *devices, error.message);
-          dbus_error_free (&error);
-          return -1;
-        }
-
-        if (!exists)
-          break;
-
-        optical_drive = TRUE;
-      }
-    }
-    libhal_free_string_array (cap_list);
-
-    if (optical_drive) {
-      XfburnDevice *device;
-      char *str, *str_vendor; 
-      const gchar *name;
-      gchar *addr = NULL;
-      gboolean dvdr = FALSE, dvdplusr = FALSE;
-
-      device = xfburn_device_new ();
-
-      /*
-      libhal_device_print (priv->hal_context, *devices, &error);
-      printf ("\n");
-
-      if (dbus_error_is_set (&error)) {
-        g_warning ("Error printing HAL device %s: %s", *devices, error.message);
-        dbus_error_free (&error);
-        return -1;
-      }
-      */
-
-      /* xfburn_device sets accessible = false by default */
-
-      str_vendor = libhal_device_get_property_string (priv->hal_context, *devices, "storage.vendor", &error);
-      if (dbus_error_is_set (&error)) {
-        g_warning ("Error getting HAL property for %s: %s", *devices, error.message);
-        dbus_error_free (&error);
-        goto not_a_device;
-      }
-
-      str = libhal_device_get_property_string (priv->hal_context, *devices, "storage.model", &error);
-      if (dbus_error_is_set (&error)) {
-        g_warning ("Error getting HAL property for %s: %s", *devices, error.message);
-        dbus_error_free (&error);
-        goto not_a_device;
-      }
-
-      name = xfburn_device_set_name (device, str_vendor, str);
-      libhal_free_string (str_vendor);
-      libhal_free_string (str);
-
-      addr = libhal_device_get_property_string (priv->hal_context, *devices, "block.device", &error);
-      if (dbus_error_is_set (&error)) {
-        g_warning ("Error getting HAL property for %s: %s", *devices, error.message);
-        dbus_error_free (&error);
-        goto not_a_device;
-      }
-
-#ifdef DEBUG_NULL_DEVICE
-      g_object_set (G_OBJECT (device), "address", "stdio:/dev/null", NULL);
-#else
-      g_object_set (G_OBJECT (device), "address", addr, NULL);
-#endif
-
-      g_object_set (G_OBJECT (device), "cdr", libhal_device_get_property_bool (priv->hal_context, *devices, "storage.cdrom.cdr", &error), NULL);
-      if (dbus_error_is_set (&error)) {
-        g_warning ("Error getting HAL property for %s: %s", *devices, error.message);
-        dbus_error_free (&error);
-        goto not_a_device;
-      }
-
-      g_object_set (G_OBJECT (device), "cdrw", libhal_device_get_property_bool (priv->hal_context, *devices, "storage.cdrom.cdrw", &error), NULL);
-      if (dbus_error_is_set (&error)) {
-        g_warning ("Error getting HAL property for %s: %s", *devices, error.message);
-        dbus_error_free (&error);
-        goto not_a_device;
-      }
-
-      dvdr = libhal_device_get_property_bool (priv->hal_context, *devices, "storage.cdrom.dvdr", &error);
-      if (dbus_error_is_set (&error)) {
-        g_warning ("Error getting HAL property for %s: %s", *devices, error.message);
-        dbus_error_free (&error);
-        goto not_a_device;
-      }
-
-      dvdplusr = libhal_device_get_property_bool (priv->hal_context, *devices, "storage.cdrom.dvdplusr", &error);
-      if (dbus_error_is_set (&error)) {
-        g_warning ("Error getting HAL property for %s: %s", *devices, error.message);
-        dbus_error_free (&error);
-        goto not_a_device;
-      }
-      g_object_set (G_OBJECT (device), "dvdr", dvdr | dvdplusr, NULL);
-
-      g_object_set (G_OBJECT (device), "dvdram", libhal_device_get_property_bool (priv->hal_context, *devices, "storage.cdrom.dvdram", &error), NULL);
-      if (dbus_error_is_set (&error)) {
-        g_warning ("Error getting HAL property for %s: %s", *devices, error.message);
-        dbus_error_free (&error);
-        goto not_a_device;
-      }
-
-      if (!xfburn_device_can_burn (device)) {
-        g_message ("Ignoring reader '%s' at '%s'", name, addr);
-        goto not_a_device;
-      }
-
-      DBG ("Found writer '%s' at '%s'", name, addr);
-      *device_list = g_list_append (*device_list, device);
-      n_devices++;
-      goto is_a_device;
-
-not_a_device:
-        g_object_unref (device);
-is_a_device:
-      libhal_free_string (addr);
-    }
-  }
-
-  libhal_free_string_array (all_devices);
-
-  return n_devices;
-}
-
-/* @Return TRUE if the drive is now accessible, FALSE if not.
- */
-gboolean
-xfburn_hal_manager_check_ask_umount (XfburnHalManager *halman, XfburnDevice *device)
-{
-  XfburnHalManagerPrivate *priv = XFBURN_HAL_MANAGER_GET_PRIVATE (halman);
-  LibHalVolume *vol;
-#ifdef HAVE_THUNAR_VFS
-  const char *mp;
-  ThunarVfsInfo *th_info;
-  ThunarVfsVolume *th_vol;
-  ThunarVfsPath *th_path;
-#endif
-  gboolean unmounted = FALSE;
-  gchar *addr;
-  
-  g_object_get (G_OBJECT (device), "address", &addr, NULL);
-  vol = libhal_volume_from_device_file (priv->hal_context, addr);
-  if (vol == NULL) {
-    /* if we can't get a volume, then we're assuming that there is no disc in the drive */
-    return TRUE;
-  }
-
-  if (!libhal_volume_is_mounted (vol))
-    return TRUE;
-
-#ifdef HAVE_THUNAR_VFS
-  mp = libhal_volume_get_mount_point (vol);
-  DBG ("%s is mounted at %s", addr, mp);
-
-
-  th_path = thunar_vfs_path_new (mp, NULL);
-  if (!th_path) {
-    g_warning ("Error getting thunar path for %s!", mp);
-    return FALSE;
-  }
-
-  th_info = thunar_vfs_info_new_for_path (th_path, NULL);
-  thunar_vfs_path_unref (th_path);
-  if (!th_info) {
-    g_warning ("Error getting thunar info for %s!", mp);
-    return FALSE;
-  }
-
-  th_vol = thunar_vfs_volume_manager_get_volume_by_info (priv->thunar_volman, th_info);
-  thunar_vfs_info_unref (th_info);
-
-  if (!th_vol) {
-    g_warning ("Error getting thunar volume for %s!", mp);
-    return FALSE;
-  }
-
-  if (!thunar_vfs_volume_is_mounted (th_vol)) {
-    return FALSE;
-  }
-
-  /* FIXME: ask if we should unmount? */
-  unmounted = thunar_vfs_volume_unmount (th_vol, NULL, NULL);
-  if (unmounted)
-    g_message ("Unmounted %s", mp);
-  else {
-    xfce_err ("Failed to unmount %s. Drive cannot be used for burning.", mp);
-    DBG ("Failed to unmount %s", mp);
-  }
-
-#endif
-  return unmounted;
-}
-
-#endif /* HAVE_HAL */
diff --git a/xfburn/xfburn-hal-manager.h b/xfburn/xfburn-hal-manager.h
deleted file mode 100644
index 89bdcf9..0000000
--- a/xfburn/xfburn-hal-manager.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  Copyright (c) 2005-2006 Jean-François Wauthy (pollux@xfce.org)
- *  Copyright (c) 2008      David Mohr (david@mcbf.net)
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef __XFBURN_HAL_MANAGER_H__
-#define __XFBURN_HAL_MANAGER_H__
-
-#ifdef HAVE_HAL
-
-#ifdef	HAVE_CONFIG_H
-#include <config.h>
-#endif /* !HAVE_CONFIG_H */
-
-#include <gtk/gtk.h>
-
-#include "xfburn-progress-dialog.h"
-#include "xfburn-device-list.h"
-
-G_BEGIN_DECLS
-
-#define XFBURN_TYPE_HAL_MANAGER         (xfburn_hal_manager_get_type ())
-#define XFBURN_HAL_MANAGER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), XFBURN_TYPE_HAL_MANAGER, XfburnHalManager))
-#define XFBURN_HAL_MANAGER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), XFBURN_TYPE_HAL_MANAGER, XfburnHalManagerClass))
-#define XFBURN_IS_HAL_MANAGER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), XFBURN_TYPE_HAL_MANAGER))
-#define XFBURN_IS_HAL_MANAGER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), XFBURN_TYPE_HAL_MANAGER))
-#define XFBURN_HAL_MANAGER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), XFBURN_TYPE_HAL_MANAGER, XfburnHalManagerClass))
-
-typedef struct
-{
-  GObject parent;
-} XfburnHalManager;
-
-typedef struct
-{
-  XfburnProgressDialogClass parent_class;
-  
-  void (*volume_changed) (XfburnHalManager *halman);
-} XfburnHalManagerClass;
-
-GType xfburn_hal_manager_get_type (void);
-//GObject *xfburn_hal_manager_new (); /* use _create_global / _get_instance instead */
-gchar *xfburn_hal_manager_create_global (void);
-XfburnHalManager * xfburn_hal_manager_get_global (void);
-void xfburn_hal_manager_shutdown (void);
-void xfburn_hal_manager_send_volume_changed (void);
-int xfburn_hal_manager_get_devices (XfburnHalManager *halman, GList **devices);
-gboolean xfburn_hal_manager_check_ask_umount (XfburnHalManager *halman, XfburnDevice *device);
-
-G_END_DECLS
-
-#endif /* HAVE_HAL */
-
-#endif /* XFBURN_HAL_MANAGER_H */
diff --git a/xfburn/xfburn-main.c b/xfburn/xfburn-main.c
index a3bd942..b9e7db0 100644
--- a/xfburn/xfburn-main.c
+++ b/xfburn/xfburn-main.c
@@ -31,10 +31,6 @@
 #include <libxfce4util/libxfce4util.h>
 #include <libxfcegui4/libxfcegui4.h>
 
-#ifdef HAVE_THUNAR_VFS
-#include <thunar-vfs/thunar-vfs.h>
-#endif
-
 #ifdef HAVE_GST
 #include <gst/gst.h>
 #endif
@@ -48,7 +44,7 @@
 #include "xfburn-burn-image-dialog.h"
 #include "xfburn-main-window.h"
 #include "xfburn-blank-dialog.h"
-#include "xfburn-hal-manager.h"
+#include "xfburn-udev-manager.h"
 #include "xfburn-transcoder-basic.h"
 #include "xfburn-transcoder-gst.h"
 
@@ -189,7 +185,7 @@ main (int argc, char **argv)
   GtkWidget *mainwin;
   gint n_burners;
   GError *error = NULL;
-#ifdef HAVE_HAL
+#ifdef HAVE_GUDEV
   gchar *error_msg;
 #endif
   XfburnTranscoder *transcoder;
@@ -275,25 +271,15 @@ main (int argc, char **argv)
 
   xfburn_settings_init ();
   
-#ifdef HAVE_THUNAR_VFS
-  thunar_vfs_init ();
-  g_message ("Using Thunar-VFS %d.%d.%d", THUNAR_VFS_MAJOR_VERSION, THUNAR_VFS_MINOR_VERSION, THUNAR_VFS_MICRO_VERSION);
-#else
-  g_message ("Thunar-VFS not available, using default implementation");
-#endif
-  
-#ifdef HAVE_HAL
-  error_msg = xfburn_hal_manager_create_global ();
+#ifdef HAVE_GUDEV
+  error_msg = xfburn_udev_manager_create_global ();
   if (error_msg) {
     xfce_err (error_msg);
-#ifdef HAVE_THUNAR_VFS
-    thunar_vfs_shutdown ();
-#endif
     gdk_threads_leave ();
     burn_finish ();
     return EXIT_FAILURE;
   } else {
-    g_message ("Using HAL");
+    g_message ("Using UDEV");
   }
 #endif
 
@@ -413,14 +399,10 @@ main (int argc, char **argv)
   g_object_unref (devlist);
   g_object_unref (transcoder);
 
-#ifdef HAVE_HAL
-  xfburn_hal_manager_shutdown ();
+#ifdef HAVE_GUDEV
+  xfburn_udev_manager_shutdown ();
 #endif
 
-#ifdef HAVE_THUNAR_VFS
-  thunar_vfs_shutdown ();
-#endif
-  
   xfburn_settings_flush ();
   xfburn_settings_free ();
   
diff --git a/xfburn/xfburn-udev-manager.c b/xfburn/xfburn-udev-manager.c
new file mode 100644
index 0000000..42427b0
--- /dev/null
+++ b/xfburn/xfburn-udev-manager.c
@@ -0,0 +1,527 @@
+/*
+ *  Copyright (c) 2005-2006 Jean-François Wauthy (pollux@xfce.org)
+ *  Copyright (c) 2008      David Mohr (dmohr@mcbf.net)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef	HAVE_CONFIG_H
+#include <config.h>
+#endif /* !HAVE_CONFIG_H */
+
+#ifdef HAVE_GUDEV
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include <gio/gio.h>
+#include <gudev/gudev.h>
+
+#include <errno.h>
+
+#include <libxfce4util/libxfce4util.h>
+#include <libxfcegui4/libxfcegui4.h>
+
+#include "xfburn-global.h"
+#include "xfburn-progress-dialog.h"
+#include "xfburn-device-list.h"
+
+#include "xfburn-udev-manager.h"
+
+static void xfburn_udev_manager_class_init (XfburnUdevManagerClass * klass);
+static void xfburn_udev_manager_init (XfburnUdevManager * obj);
+static void xfburn_udev_manager_finalize (GObject * object);
+
+static GObject * xfburn_udev_manager_new (void);
+
+static void cb_device_monitor_uevent(GUdevClient  *client, const gchar  *action, GUdevDevice  *udevice, XfburnUdevManager *obj);
+
+#define XFBURN_UDEV_MANAGER_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), XFBURN_TYPE_UDEV_MANAGER, XfburnUdevManagerPrivate))
+
+enum {
+  VOLUME_CHANGED,
+  LAST_SIGNAL,
+};
+
+typedef struct {
+  GUdevClient *client;
+  GVolumeMonitor *volume_monitor;
+  gchar *error;
+} XfburnUdevManagerPrivate;
+
+typedef struct {
+  GMainLoop *loop;
+  GCancellable *cancel;
+  guint timeout_id;
+  gboolean result;
+  GError *error;
+} XfburnUdevManagerGioOperation;
+
+static XfburnUdevManager *instance = NULL;
+
+/*********************/
+/* class declaration */
+/*********************/
+static XfburnProgressDialogClass *parent_class = NULL;
+static guint signals[LAST_SIGNAL];
+
+GType
+xfburn_udev_manager_get_type (void)
+{
+  static GType type = 0;
+
+  if (type == 0) {
+    static const GTypeInfo our_info = {
+      sizeof (XfburnUdevManagerClass),
+      NULL,
+      NULL,
+      (GClassInitFunc) xfburn_udev_manager_class_init,
+      NULL,
+      NULL,
+      sizeof (XfburnUdevManager),
+      0,
+      (GInstanceInitFunc) xfburn_udev_manager_init,
+      NULL
+    };
+
+    type = g_type_register_static (G_TYPE_OBJECT, "XfburnUdevManager", &our_info, 0);
+  }
+
+  return type;
+}
+
+static void
+xfburn_udev_manager_class_init (XfburnUdevManagerClass * klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (XfburnUdevManagerPrivate));
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  object_class->finalize = xfburn_udev_manager_finalize;
+
+  signals[VOLUME_CHANGED] = g_signal_new ("volume-changed", XFBURN_TYPE_UDEV_MANAGER, G_SIGNAL_ACTION,
+                                          G_STRUCT_OFFSET (XfburnUdevManagerClass, volume_changed),
+                                          NULL, NULL, g_cclosure_marshal_VOID__VOID,
+                                          G_TYPE_NONE, 0);
+}
+
+static void
+xfburn_udev_manager_init (XfburnUdevManager * obj)
+{
+  XfburnUdevManagerPrivate *priv = XFBURN_UDEV_MANAGER_GET_PRIVATE (obj);
+  const gchar* const subsystems[] = { "block", NULL };
+
+  priv->error = NULL;
+  priv->volume_monitor = NULL;
+  priv->client = g_udev_client_new (subsystems);
+  if (G_LIKELY (priv->client != NULL)) {
+    g_signal_connect (G_OBJECT (priv->client), "uevent",
+		      G_CALLBACK (cb_device_monitor_uevent), obj);
+
+    priv->volume_monitor = g_volume_monitor_get();
+    if (priv->volume_monitor != NULL) {
+      //g_signal_connect (G_OBJECT (priv->volume_monitor), "volume-added", G_CALLBACK (cb_volumes_changed), box);
+      //g_signal_connect (G_OBJECT (priv->volume_monitor), "volume-removed", G_CALLBACK (cb_volumes_changed), box);
+    } else {
+      g_warning ("Error trying to access g_volume_monitor!");
+    }
+  }
+}
+
+static void
+xfburn_udev_manager_finalize (GObject * object)
+{
+  XfburnUdevManagerPrivate *priv = XFBURN_UDEV_MANAGER_GET_PRIVATE (object);
+
+  g_object_unref (priv->volume_monitor);
+  g_object_unref (priv->client);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+  instance = NULL;
+}
+
+static void cb_device_monitor_uevent(GUdevClient  *client,
+				     const gchar  *action,
+				     GUdevDevice  *udevice,
+				     XfburnUdevManager *obj)
+{
+  DBG ("UDEV: device uevent: %s", action);
+
+  if (g_str_equal (action, "remove") || g_str_equal (action, "add"))
+    g_signal_emit (instance, signals[VOLUME_CHANGED], 0);
+
+  /* Lets ignore this for now,
+   * way too many of these get triggered when a disc is
+   * inserted or removed!
+  DBG ("HAL: property modified");
+  g_signal_emit (instance, signals[VOLUME_CHANGED], 0);
+  */
+}
+
+static GObject *
+xfburn_udev_manager_new (void)
+{
+  if (G_UNLIKELY (instance != NULL))
+    g_error ("Trying to create a second instance of udev manager!");
+  return g_object_new (XFBURN_TYPE_UDEV_MANAGER, NULL);
+}
+
+/*        */
+/* public */
+/*        */
+
+gchar *
+xfburn_udev_manager_create_global (void)
+{
+  XfburnUdevManagerPrivate *priv;
+
+  instance = XFBURN_UDEV_MANAGER (xfburn_udev_manager_new ());
+
+  priv = XFBURN_UDEV_MANAGER_GET_PRIVATE (instance);
+
+  if (priv->error) {
+    gchar *error_msg, *ret;
+
+    error_msg = g_strdup (priv->error);
+    xfburn_udev_manager_shutdown ();
+    ret = g_strdup_printf ("Failed to initialize %s!", error_msg);
+    g_free (error_msg);
+    return ret;
+  } else
+    return NULL;
+}
+
+XfburnUdevManager *
+xfburn_udev_manager_get_global (void)
+{
+  if (G_UNLIKELY (instance == NULL))
+    g_error ("There is no instance of a udev manager!");
+  return instance;
+}
+
+void
+xfburn_udev_manager_shutdown (void)
+{
+  if (G_UNLIKELY (instance == NULL))
+    g_error ("There is no instance of a udev manager!");
+  g_object_unref (instance);
+  instance = NULL;
+}
+
+void
+xfburn_udev_manager_send_volume_changed (void)
+{
+  //gdk_threads_enter ();
+  g_signal_emit (instance, signals[VOLUME_CHANGED], 0);
+  //gdk_threads_leave ();
+}
+
+GList *
+xfburn_udev_manager_get_devices (XfburnUdevManager *udevman, gint *drives, gint *burners)
+{
+  XfburnUdevManagerPrivate *priv = XFBURN_UDEV_MANAGER_GET_PRIVATE (udevman);
+  GList *devices, *l;
+  GList *device_list = NULL;
+
+  (*drives) = 0;
+  (*burners) = 0;
+
+  if (priv->client == NULL)
+    return NULL;
+
+  devices = g_udev_client_query_by_subsystem (priv->client, "block");
+  for (l = devices; l != NULL; l = l->next) {
+    const gchar *id_type = g_udev_device_get_property (l->data, "ID_TYPE");
+    if (g_strcmp0 (id_type, "cd") == 0) {
+      gboolean cdr = g_udev_device_get_property_as_boolean(l->data, "ID_CDROM_CD_R");
+      gboolean cdrw = g_udev_device_get_property_as_boolean(l->data, "ID_CDROM_CD_RW");
+      gboolean dvdr = g_udev_device_get_property_as_boolean(l->data, "ID_CDROM_DVD_R")
+	           || g_udev_device_get_property_as_boolean(l->data, "ID_CDROM_DVD_RW")
+                   || g_udev_device_get_property_as_boolean(l->data, "ID_CDROM_DVD_PLUS_R")
+                   || g_udev_device_get_property_as_boolean(l->data, "ID_CDROM_DVD_PLUS_RW")
+                   || g_udev_device_get_property_as_boolean(l->data, "ID_CDROM_DVD_PLUS_R_DL");
+      gboolean dvdram = g_udev_device_get_property_as_boolean(l->data, "ID_CDROM_DVD_RAM");
+
+      (*drives)++;
+
+      if (cdr || dvdr || dvdram) {
+        XfburnDevice *device;
+        const gchar *addr, *name, *str_model, *str_vendor;
+
+        device = xfburn_device_new ();
+
+	/* vendor */
+	str_vendor = g_udev_device_get_sysfs_attr(l->data, "device/vendor");
+        if (str_vendor == NULL)
+	  str_vendor = g_udev_device_get_property (l->data, "ID_VENDOR_FROM_DATABASE");
+        if (str_vendor == NULL)
+          str_vendor = g_udev_device_get_property (l->data, "ID_VENDOR");
+	if (str_vendor == NULL)
+          str_vendor = g_udev_device_get_sysfs_attr (l->data, "manufacturer");
+
+        /* model */
+	str_model = g_udev_device_get_sysfs_attr(l->data, "device/model");
+        if (str_model == NULL)
+          str_model = g_udev_device_get_property (l->data, "ID_MODEL_FROM_DATABASE");
+        if (str_model == NULL)
+          str_model = g_udev_device_get_property (l->data, "ID_MODEL");
+        if (str_model == NULL)
+          str_model = g_udev_device_get_sysfs_attr (l->data, "product");
+
+        name = xfburn_device_set_name (device, str_vendor, str_model);
+
+        addr = g_udev_device_get_device_file(l->data);
+#ifdef DEBUG_NULL_DEVICE
+        g_object_set (G_OBJECT (device), "address", "stdio:/dev/null", NULL);
+#else
+        g_object_set (G_OBJECT (device), "address", addr, NULL);
+#endif
+
+        g_object_set (G_OBJECT (device), "cdr", cdr, NULL);
+        g_object_set (G_OBJECT (device), "cdrw", cdrw, NULL);
+        g_object_set (G_OBJECT (device), "dvdr", dvdr, NULL);
+        g_object_set (G_OBJECT (device), "dvdram", dvdram, NULL);
+
+        if (!xfburn_device_can_burn (device)) {
+          g_message ("Ignoring reader '%s' at '%s'", name, addr);
+          g_object_unref (device);
+        } else {
+          (*burners)++;
+          device_list = g_list_append (device_list, device);
+          DBG ("Found writer '%s' at '%s'", name, addr);
+        }
+      }
+    }
+    g_object_unref (l->data);
+  }
+  g_list_free (devices);
+  return device_list;
+}
+
+static void
+xfburn_udev_manager_gio_operation_end (gpointer callback_data)
+{
+  XfburnUdevManagerGioOperation *operation = callback_data;
+
+  if (!operation->loop)
+    return;
+  if (!g_main_loop_is_running (operation->loop))
+    return;
+  g_main_loop_quit (operation->loop);
+}
+
+static void
+cb_device_umounted (GMount *mount,
+                    XfburnUdevManagerGioOperation *operation)
+{
+  xfburn_udev_manager_gio_operation_end (operation);
+  operation->result = TRUE;
+}
+
+static void
+cb_device_umount_finish (GObject *source,
+                         GAsyncResult *result,
+                         gpointer user_data)
+{
+  XfburnUdevManagerGioOperation *op = user_data;
+
+  if (!op->loop)
+    return;
+
+  op->result = g_mount_unmount_with_operation_finish (G_MOUNT (source),
+						    result,
+						    &op->error);
+
+  g_debug("Umount operation completed (result = %d)", op->result);
+
+  if (op->error) {
+    if (op->error->code == G_IO_ERROR_NOT_MOUNTED) {
+      /* That can happen sometimes */
+      g_error_free (op->error);
+      op->error = NULL;
+      op->result = TRUE;
+    }
+    /* Since there was an error. The "unmounted" signal won't be
+     * emitted by GVolumeMonitor and therefore we'd get stuck if
+     * we didn't get out of the loop. */
+    xfburn_udev_manager_gio_operation_end (op);
+  } else if (!op->result) {
+    xfburn_udev_manager_gio_operation_end (op);
+  }
+}
+
+static void
+cb_gio_operation_cancelled (GCancellable *cancel,
+                            XfburnUdevManagerGioOperation *operation)
+{
+  operation->result = FALSE;
+  g_cancellable_cancel (operation->cancel);
+  if (operation->loop && g_main_loop_is_running (operation->loop))
+    g_main_loop_quit (operation->loop);
+}
+
+static gboolean
+cb_gio_operation_timeout (gpointer callback_data)
+{
+  XfburnUdevManagerGioOperation *operation = callback_data;
+
+  g_warning ("Volume/Disc operation timed out");
+
+  xfburn_udev_manager_gio_operation_end (operation);
+  operation->timeout_id = 0;
+  operation->result = FALSE;
+  return FALSE;
+}
+
+/* @Return TRUE if the drive is now accessible, FALSE if not.
+ */
+gboolean
+xfburn_udev_manager_check_ask_umount (XfburnUdevManager *udevman, XfburnDevice *device)
+{
+  XfburnUdevManagerPrivate *priv = XFBURN_UDEV_MANAGER_GET_PRIVATE (udevman);
+  gboolean unmounted = FALSE;
+  gchar *device_file;
+  GList *mounts;
+  GMount *mount = NULL;
+  GList *i;
+  gchar *mp;
+
+  if (priv->volume_monitor == NULL)
+    return FALSE;
+
+  mounts = g_volume_monitor_get_mounts (priv->volume_monitor);
+
+  g_object_get (G_OBJECT (device), "address", &device_file, NULL);
+  for (i = mounts; i != NULL; i = i->next) {
+    GVolume *v;
+
+    mount = G_MOUNT (i->data);
+    v = g_mount_get_volume (mount);
+    if (v != NULL) {
+      char *devname = NULL;
+      gboolean match;
+
+      devname = g_volume_get_identifier (v, G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE);
+      match = g_str_equal (devname, device_file);
+
+      g_free (devname);
+      g_object_unref (v);
+
+      if (match)
+        break;
+    }
+    g_object_unref (mount);
+    mount = NULL;
+  }
+  g_list_free (mounts);
+
+  if (mount == NULL)
+    return TRUE;
+
+  if (g_mount_can_unmount (mount)) {
+    /* FIXME: ask if we should unmount? */
+    gulong umount_sig;
+    XfburnUdevManagerGioOperation *op;
+
+    op = g_new0 (XfburnUdevManagerGioOperation, 1);
+    op->cancel = g_cancellable_new();
+
+    umount_sig = g_signal_connect_after (mount,
+                                         "unmounted",
+                                         G_CALLBACK (cb_device_umounted),
+                                         op);
+
+    /* NOTE: we own a reference to mount
+     * object so no need to ref it even more */
+    g_mount_unmount_with_operation (mount,
+                                    G_MOUNT_UNMOUNT_NONE,
+                                    NULL,
+                                    op->cancel,
+                                    cb_device_umount_finish,
+                                    op);
+    DBG("Waiting for end of async operation");
+    g_cancellable_reset (op->cancel);
+    g_signal_connect (op->cancel,
+                      "cancelled",
+                      G_CALLBACK (cb_gio_operation_cancelled),
+                      op);
+
+    /* put a timeout (15 sec) */
+    op->timeout_id = g_timeout_add_seconds (15,
+                                            cb_gio_operation_timeout,
+                                            op);
+
+    op->loop = g_main_loop_new (NULL, FALSE);
+
+    GDK_THREADS_LEAVE ();
+    g_main_loop_run (op->loop);
+    GDK_THREADS_ENTER ();
+
+    g_main_loop_unref (op->loop);
+    op->loop = NULL;
+
+    if (op->timeout_id) {
+      g_source_remove (op->timeout_id);
+      op->timeout_id = 0;
+    }
+
+    if (op->error) {
+      g_warning ("Medium op finished with an error: %s", op->error->message);
+
+      if (op->error->code == G_IO_ERROR_FAILED_HANDLED) {
+        DBG("Error already handled and displayed by GIO");
+
+        /* means we shouldn't display any error message since
+         * that was already done */
+        g_error_free (op->error);
+        op->error = NULL;
+      } else
+        g_error_free (op->error);
+
+      op->error = NULL;
+    }
+
+    unmounted = op->result;
+
+    if (op->cancel) {
+      g_cancellable_cancel (op->cancel);
+      g_object_unref (op->cancel);
+    }
+    if (op->timeout_id) {
+      g_source_remove (op->timeout_id);
+    }
+    if (op->loop && g_main_loop_is_running (op->loop))
+      g_main_loop_quit (op->loop);
+    g_signal_handler_disconnect (mount, umount_sig);
+  }
+
+  mp = g_mount_get_name(mount);
+  if (unmounted)
+    g_message ("Unmounted '%s'", mp);
+  else {
+    xfce_err ("Failed to unmount '%s'. Drive cannot be used for burning.", mp);
+    DBG ("Failed to unmount '%s'", mp);
+  }
+
+  g_free(mp);
+  g_object_unref (mount);
+
+  return unmounted;
+}
+
+#endif /* HAVE_GUDEV */
diff --git a/xfburn/xfburn-udev-manager.h b/xfburn/xfburn-udev-manager.h
new file mode 100644
index 0000000..8f71292
--- /dev/null
+++ b/xfburn/xfburn-udev-manager.h
@@ -0,0 +1,68 @@
+/*
+ *  Copyright (c) 2005-2006 Jean-François Wauthy (pollux@xfce.org)
+ *  Copyright (c) 2008      David Mohr (david@mcbf.net)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __XFBURN_UDEV_MANAGER_H__
+#define __XFBURN_UDEV_MANAGER_H__
+
+#ifdef HAVE_GUDEV
+
+#ifdef	HAVE_CONFIG_H
+#include <config.h>
+#endif /* !HAVE_CONFIG_H */
+
+#include <gtk/gtk.h>
+
+#include "xfburn-progress-dialog.h"
+#include "xfburn-device-list.h"
+
+G_BEGIN_DECLS
+
+#define XFBURN_TYPE_UDEV_MANAGER         (xfburn_udev_manager_get_type ())
+#define XFBURN_UDEV_MANAGER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), XFBURN_TYPE_UDEV_MANAGER, XfburnUdevManager))
+#define XFBURN_UDEV_MANAGER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), XFBURN_TYPE_UDEV_MANAGER, XfburnUdevManagerClass))
+#define XFBURN_IS_UDEV_MANAGER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), XFBURN_TYPE_UDEV_MANAGER))
+#define XFBURN_IS_UDEV_MANAGER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), XFBURN_TYPE_UDEV_MANAGER))
+#define XFBURN_UDEV_MANAGER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), XFBURN_TYPE_UDEV_MANAGER, XfburnUdevManagerClass))
+
+typedef struct
+{
+  GObject parent;
+} XfburnUdevManager;
+
+typedef struct
+{
+  XfburnProgressDialogClass parent_class;
+
+  void (*volume_changed) (XfburnUdevManager *udevman);
+} XfburnUdevManagerClass;
+
+GType xfburn_udev_manager_get_type (void);
+//GObject *xfburn_udev_manager_new (); /* use _create_global / _get_instance instead */
+gchar *xfburn_udev_manager_create_global (void);
+XfburnUdevManager * xfburn_udev_manager_get_global (void);
+void xfburn_udev_manager_shutdown (void);
+void xfburn_udev_manager_send_volume_changed (void);
+GList *xfburn_udev_manager_get_devices (XfburnUdevManager *udevman, gint *drives, gint *burners);
+gboolean xfburn_udev_manager_check_ask_umount (XfburnUdevManager *udevman, XfburnDevice *device);
+
+G_END_DECLS
+
+#endif /* HAVE_GUDEV */
+
+#endif /* XFBURN_UDEV_MANAGER_H */
--
1.7.8.1
